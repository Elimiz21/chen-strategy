# Phase 1: Regime Detection Approaches Survey

## Document Control
- Version: 1.0
- Date: 2025-12-23
- Owner: ML/Stats Lead
- Status: IN PROGRESS

---

## 1. Executive Summary

This document surveys approaches for detecting market regimes in QQQ. The goal is to identify 3+ viable approaches that can be implemented and tested in Phase 4, with focus on real-time applicability (no look-ahead) and calibration quality.

---

## 2. Regime Detection Approaches Overview

### Taxonomy of Approaches

```
Regime Detection
├── Rules-Based
│   ├── Moving Average Based
│   ├── Volatility Thresholds
│   └── Momentum Thresholds
├── Statistical/ML
│   ├── Hidden Markov Models (HMM)
│   ├── Threshold Autoregressive (TAR)
│   ├── Markov-Switching Models
│   └── Clustering (K-means, GMM)
└── Hybrid
    ├── Rules + ML Confirmation
    └── Ensemble Methods
```

---

## 3. Approach 1: Rules-Based (Moving Average)

### 3.1 Description
Use simple moving average relationships to define trend regimes.

### 3.2 Implementation

```python
def detect_regime_ma(price, sma_50, sma_200):
    """
    Rules-based regime detection using moving averages.

    Returns:
        'BULL': Price > 200 SMA AND 50 SMA > 200 SMA
        'BEAR': Price < 200 SMA AND 50 SMA < 200 SMA
        'TRANSITION': Otherwise
    """
    if price > sma_200 and sma_50 > sma_200:
        return 'BULL'
    elif price < sma_200 and sma_50 < sma_200:
        return 'BEAR'
    else:
        return 'TRANSITION'
```

### 3.3 Pros and Cons

| Pros | Cons |
|------|------|
| Simple and interpretable | Lagging (uses 200-day data) |
| No look-ahead by construction | Whipsaws in transitions |
| Robust, well-understood | Binary states only |
| Low computational cost | No probability estimates |

### 3.4 Enhancement: Volatility Overlay

```python
def detect_regime_ma_vol(price, sma_50, sma_200, atr_20, atr_60):
    """
    Trend regime + volatility regime.
    """
    # Trend regime
    if price > sma_200 and sma_50 > sma_200:
        trend = 'BULL'
    elif price < sma_200 and sma_50 < sma_200:
        trend = 'BEAR'
    else:
        trend = 'TRANSITION'

    # Volatility regime
    vol_ratio = atr_20 / atr_60
    if vol_ratio > 1.5:
        vol = 'HIGH'
    elif vol_ratio < 0.75:
        vol = 'LOW'
    else:
        vol = 'NORMAL'

    return f"{trend}_{vol}"
```

### 3.5 Expected Performance

| Metric | Estimate |
|--------|----------|
| Accuracy (hit rate) | 60-70% |
| Regime persistence | 20-60 days avg |
| Transition speed | 10-20 day lag |
| Look-ahead risk | None |

---

## 4. Approach 2: Hidden Markov Model (HMM)

### 4.1 Description
Unsupervised probabilistic model that assumes observed returns are generated by a hidden state (regime) that follows a Markov process.

### 4.2 Model Specification

```python
from hmmlearn import hmm

class RegimeHMM:
    """
    Hidden Markov Model for regime detection.

    States:
        - State 0: Low volatility bull (high mean, low variance)
        - State 1: High volatility (low/negative mean, high variance)
        - State 2: Normal (moderate mean, moderate variance)
    """
    def __init__(self, n_states=3):
        self.model = hmm.GaussianHMM(
            n_components=n_states,
            covariance_type="full",
            n_iter=1000
        )

    def fit(self, returns):
        """Fit on training data only."""
        self.model.fit(returns.reshape(-1, 1))
        return self

    def predict(self, returns):
        """Predict regime for new data."""
        return self.model.predict(returns.reshape(-1, 1))

    def predict_proba(self, returns):
        """Get regime probabilities."""
        return self.model.predict_proba(returns.reshape(-1, 1))
```

### 4.3 Training Protocol (Avoid Look-Ahead)

```python
def train_hmm_walk_forward(returns, train_window=252*5, step=21):
    """
    Walk-forward HMM training to avoid look-ahead.

    - Train on rolling 5-year window
    - Retrain monthly
    - Predict only on future data
    """
    predictions = []

    for t in range(train_window, len(returns), step):
        # Train on past data only
        train_data = returns[t-train_window:t]
        model = RegimeHMM(n_states=3)
        model.fit(train_data)

        # Predict next period
        test_data = returns[t:t+step]
        pred = model.predict(test_data)
        predictions.extend(pred)

    return predictions
```

### 4.4 Pros and Cons

| Pros | Cons |
|------|------|
| Data-driven regime discovery | Requires careful training protocol |
| Provides probability estimates | Can overfit |
| Captures complex patterns | States may not be interpretable |
| Well-established methodology | Sensitive to initialization |

### 4.5 Calibration Requirements

1. **Reliability diagram**: Plot predicted probability vs actual outcome
2. **Brier score**: Measure probability accuracy
3. **Regime persistence**: Check if predicted regimes are actionable (not too short)

### 4.6 Expected Performance

| Metric | Estimate |
|--------|----------|
| Accuracy (if well-calibrated) | 55-65% |
| Regime persistence | 10-40 days avg |
| Probability calibration | Requires validation |
| Look-ahead risk | HIGH if not careful |

---

## 5. Approach 3: Threshold Model (Volatility-Based)

### 5.1 Description
Use realized volatility thresholds to define volatility regimes, with trend overlay from price momentum.

### 5.2 Implementation

```python
import numpy as np

def detect_regime_threshold(returns, window=20):
    """
    Threshold-based regime detection.

    Uses realized volatility percentiles and momentum.
    """
    # Calculate realized volatility
    realized_vol = returns.rolling(window).std() * np.sqrt(252)

    # Calculate momentum (12-1 month)
    momentum = returns.rolling(252).sum() - returns.rolling(21).sum()

    # Volatility regime (based on historical percentiles)
    vol_percentile = realized_vol.rank(pct=True)

    # Classify
    def classify(vol_pct, mom):
        if vol_pct > 0.8:
            vol_regime = 'HIGH_VOL'
        elif vol_pct < 0.2:
            vol_regime = 'LOW_VOL'
        else:
            vol_regime = 'NORMAL_VOL'

        if mom > 0:
            trend = 'BULL'
        else:
            trend = 'BEAR'

        return f"{trend}_{vol_regime}"

    return [classify(v, m) for v, m in zip(vol_percentile, momentum)]
```

### 5.3 Pros and Cons

| Pros | Cons |
|------|------|
| Intuitive interpretation | Threshold selection arbitrary |
| Captures volatility dynamics | May miss complex patterns |
| Fast to compute | No probability estimates |
| Easy to validate | Percentile ranking looks back |

### 5.4 Expected Performance

| Metric | Estimate |
|--------|----------|
| Accuracy | 55-65% |
| Regime persistence | 15-30 days avg |
| Transition speed | Fast (daily update) |
| Look-ahead risk | Low (uses rolling windows) |

---

## 6. Approach 4: Hybrid (Rules + ML Confirmation)

### 6.1 Description
Use rules-based detection as primary, with ML model providing confidence scores for "tilt not switch" behavior.

### 6.2 Implementation

```python
class HybridRegimeDetector:
    """
    Hybrid regime detection combining rules and ML.
    """
    def __init__(self):
        self.hmm = RegimeHMM(n_states=3)
        self.rules_weight = 0.6
        self.ml_weight = 0.4

    def detect(self, price, sma_50, sma_200, returns):
        # Rules-based regime
        rules_regime = detect_regime_ma(price, sma_50, sma_200)

        # ML regime probability
        ml_proba = self.hmm.predict_proba(returns[-1:])

        # Map rules regime to index
        regime_map = {'BULL': 0, 'BEAR': 1, 'TRANSITION': 2}
        rules_idx = regime_map[rules_regime]

        # Combined confidence
        rules_conf = 1.0 if rules_regime != 'TRANSITION' else 0.5
        ml_conf = ml_proba[0, rules_idx]

        combined_conf = (self.rules_weight * rules_conf +
                        self.ml_weight * ml_conf)

        return {
            'regime': rules_regime,
            'confidence': combined_conf,
            'ml_proba': ml_proba[0]
        }

    def get_position_multiplier(self, detection):
        """
        Tilt not switch: scale position by confidence.
        """
        if detection['confidence'] > 0.8:
            return 1.0  # Full position
        elif detection['confidence'] > 0.6:
            return 0.7  # Reduced position
        elif detection['confidence'] > 0.4:
            return 0.4  # Minimal position
        else:
            return 0.0  # Cash
```

### 6.3 Pros and Cons

| Pros | Cons |
|------|------|
| Interpretable primary signal | More complex to implement |
| Probabilistic refinement | Requires tuning of weights |
| "Tilt not switch" natural | Two models to maintain |
| Best of both worlds | More parameters to validate |

### 6.4 Expected Performance

| Metric | Estimate |
|--------|----------|
| Accuracy | 60-70% |
| Confidence calibration | Good if validated |
| Regime persistence | 15-45 days avg |
| Look-ahead risk | Moderate (depends on ML) |

---

## 7. Comparison Matrix

| Approach | Simplicity | Accuracy | Calibration | Look-Ahead Risk | Recommendation |
|----------|------------|----------|-------------|-----------------|----------------|
| Rules-Based (MA) | High | Medium | N/A | None | Primary |
| HMM | Low | Medium-High | Requires work | High | Secondary |
| Threshold | Medium | Medium | N/A | Low | Alternative |
| Hybrid | Medium | Medium-High | Good | Moderate | Preferred |

---

## 8. Recommended Implementation Plan

### Phase 4 Implementation Priority

1. **Rules-Based (MA + Vol)** - Implement first as interpretable baseline
2. **Threshold Model** - Fast alternative, easy to validate
3. **HMM** - Implement with strict walk-forward protocol
4. **Hybrid** - Combine best elements after validating components

### Validation Requirements (Per Approach)

| Requirement | Rules | Threshold | HMM | Hybrid |
|-------------|-------|-----------|-----|--------|
| Walk-forward test | Yes | Yes | Critical | Yes |
| Regime persistence > 5 days | Check | Check | Check | Check |
| No look-ahead audit | Verify | Verify | Critical | Verify |
| Calibration diagram | N/A | N/A | Required | Required |
| Subperiod stability | Test | Test | Test | Test |
| Expert performance by regime | Test | Test | Test | Test |

---

## 9. Key Considerations for QQQ

### QQQ-Specific Factors

1. **Higher volatility than SPY** - Vol regimes more pronounced
2. **Tech concentration** - Sector moves may dominate
3. **Faster regime transitions** - Need responsive detection
4. **V-shaped recoveries** - Bear regimes may be short

### Recommended Regime States for QQQ

| State | Definition | Expected Behavior |
|-------|------------|-------------------|
| BULL_LOW_VOL | Uptrend + calm | Trend-following works best |
| BULL_HIGH_VOL | Uptrend + volatile | Reduce exposure, trend still valid |
| BEAR_HIGH_VOL | Downtrend + volatile | Short or cash, high uncertainty |
| BEAR_LOW_VOL | Downtrend + calm | Rare, short position viable |
| TRANSITION | Unclear trend | Cash or minimal position |

---

## 10. Next Steps

1. **Phase 2**: Acquire QQQ data, implement basic indicators
2. **Phase 4**: Implement all 4 approaches
3. **Phase 4**: Validate calibration and look-ahead compliance
4. **Phase 4**: Measure expert performance by detected regime
5. **Phase 5**: Select best approach for meta-allocation

---

## 11. References

1. Hamilton, J. D. (1989). A new approach to the economic analysis of nonstationary time series and the business cycle. Econometrica.
2. Ang, A., & Bekaert, G. (2002). Regime switches in interest rates. Journal of Business & Economic Statistics.
3. Guidolin, M., & Timmermann, A. (2007). Asset allocation under multivariate regime switching. Journal of Economic Dynamics and Control.
4. Bulla, J., & Bulla, I. (2006). Stylized facts of financial time series and hidden semi-Markov models. Computational Statistics & Data Analysis.
5. Nystrup, P., Hansen, B. W., Madsen, H., & Lindström, E. (2017). Regime-based versus static asset allocation. Journal of Portfolio Management.

---

## Appendix: Code Snippets

### A.1 Regime Labeling for Backtesting

```python
def label_historical_regimes(df, approach='rules_ma'):
    """
    Label historical regimes for backtesting expert performance.

    Args:
        df: DataFrame with price, sma_50, sma_200, returns
        approach: 'rules_ma', 'threshold', 'hmm', 'hybrid'

    Returns:
        Series of regime labels
    """
    if approach == 'rules_ma':
        return df.apply(
            lambda row: detect_regime_ma(
                row['close'], row['sma_50'], row['sma_200']
            ), axis=1
        )
    elif approach == 'threshold':
        return detect_regime_threshold(df['returns'])
    # Add other approaches...
```

### A.2 Regime Transition Matrix

```python
def compute_transition_matrix(regimes):
    """
    Compute regime transition probabilities.
    """
    from collections import Counter

    transitions = Counter(zip(regimes[:-1], regimes[1:]))
    states = sorted(set(regimes))
    n_states = len(states)

    matrix = np.zeros((n_states, n_states))
    state_to_idx = {s: i for i, s in enumerate(states)}

    for (from_state, to_state), count in transitions.items():
        matrix[state_to_idx[from_state], state_to_idx[to_state]] = count

    # Normalize rows
    matrix = matrix / matrix.sum(axis=1, keepdims=True)

    return matrix, states
```
